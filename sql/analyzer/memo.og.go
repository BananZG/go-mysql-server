// Code generated by optgen; DO NOT EDIT.

package analyzer

import (
	"fmt"
	"strings"

	"github.com/dolthub/go-mysql-server/sql"
	"github.com/dolthub/go-mysql-server/sql/expression"
	"github.com/dolthub/go-mysql-server/sql/plan"
)

type crossJoin struct {
	*joinBase
}

var _ relExpr = (*crossJoin)(nil)
var _ joinRel = (*crossJoin)(nil)

func (r *crossJoin) String() string {
	return formatExpr(r)
}

func (r *crossJoin) joinPrivate() *joinBase {
	return r.joinBase
}

type innerJoin struct {
	*joinBase
}

var _ relExpr = (*innerJoin)(nil)
var _ joinRel = (*innerJoin)(nil)

func (r *innerJoin) String() string {
	return formatExpr(r)
}

func (r *innerJoin) joinPrivate() *joinBase {
	return r.joinBase
}

type leftJoin struct {
	*joinBase
}

var _ relExpr = (*leftJoin)(nil)
var _ joinRel = (*leftJoin)(nil)

func (r *leftJoin) String() string {
	return formatExpr(r)
}

func (r *leftJoin) joinPrivate() *joinBase {
	return r.joinBase
}

type semiJoin struct {
	*joinBase
}

var _ relExpr = (*semiJoin)(nil)
var _ joinRel = (*semiJoin)(nil)

func (r *semiJoin) String() string {
	return formatExpr(r)
}

func (r *semiJoin) joinPrivate() *joinBase {
	return r.joinBase
}

type antiJoin struct {
	*joinBase
}

var _ relExpr = (*antiJoin)(nil)
var _ joinRel = (*antiJoin)(nil)

func (r *antiJoin) String() string {
	return formatExpr(r)
}

func (r *antiJoin) joinPrivate() *joinBase {
	return r.joinBase
}

type lookupJoin struct {
	*joinBase
	lookup *lookup
}

var _ relExpr = (*lookupJoin)(nil)
var _ joinRel = (*lookupJoin)(nil)

func (r *lookupJoin) String() string {
	return formatExpr(r)
}

func (r *lookupJoin) joinPrivate() *joinBase {
	return r.joinBase
}

type concatJoin struct {
	*joinBase
	concat []*lookup
}

var _ relExpr = (*concatJoin)(nil)
var _ joinRel = (*concatJoin)(nil)

func (r *concatJoin) String() string {
	return formatExpr(r)
}

func (r *concatJoin) joinPrivate() *joinBase {
	return r.joinBase
}

type hashJoin struct {
	*joinBase
	innerAttrs []*exprGroup
	outerAttrs []*exprGroup
}

var _ relExpr = (*hashJoin)(nil)
var _ joinRel = (*hashJoin)(nil)

func (r *hashJoin) String() string {
	return formatExpr(r)
}

func (r *hashJoin) joinPrivate() *joinBase {
	return r.joinBase
}

type mergeJoin struct {
	*joinBase
	innerScan *indexScan
	outerScan *indexScan
}

var _ relExpr = (*mergeJoin)(nil)
var _ joinRel = (*mergeJoin)(nil)

func (r *mergeJoin) String() string {
	return formatExpr(r)
}

func (r *mergeJoin) joinPrivate() *joinBase {
	return r.joinBase
}

type fullOuterJoin struct {
	*joinBase
}

var _ relExpr = (*fullOuterJoin)(nil)
var _ joinRel = (*fullOuterJoin)(nil)

func (r *fullOuterJoin) String() string {
	return formatExpr(r)
}

func (r *fullOuterJoin) joinPrivate() *joinBase {
	return r.joinBase
}

type tableScan struct {
	*relBase
	table *plan.ResolvedTable
}

var _ relExpr = (*tableScan)(nil)
var _ sourceRel = (*tableScan)(nil)

func (r *tableScan) String() string {
	return formatExpr(r)
}

func (r *tableScan) name() string {
	return strings.ToLower(r.table.Name())
}

func (r *tableScan) tableId() TableId {
	return tableIdForSource(r.g.id)
}

func (r *tableScan) outputCols() sql.Schema {
	return r.table.Schema()
}

func (r *tableScan) children() []*exprGroup {
	return nil
}

type values struct {
	*relBase
	table *plan.ValueDerivedTable
}

var _ relExpr = (*values)(nil)
var _ sourceRel = (*values)(nil)

func (r *values) String() string {
	return formatExpr(r)
}

func (r *values) name() string {
	return strings.ToLower(r.table.Name())
}

func (r *values) tableId() TableId {
	return tableIdForSource(r.g.id)
}

func (r *values) outputCols() sql.Schema {
	return r.table.Schema()
}

func (r *values) children() []*exprGroup {
	return nil
}

type tableAlias struct {
	*relBase
	table *plan.TableAlias
}

var _ relExpr = (*tableAlias)(nil)
var _ sourceRel = (*tableAlias)(nil)

func (r *tableAlias) String() string {
	return formatExpr(r)
}

func (r *tableAlias) name() string {
	return strings.ToLower(r.table.Name())
}

func (r *tableAlias) tableId() TableId {
	return tableIdForSource(r.g.id)
}

func (r *tableAlias) outputCols() sql.Schema {
	return r.table.Schema()
}

func (r *tableAlias) children() []*exprGroup {
	return nil
}

type recursiveTable struct {
	*relBase
	table *plan.RecursiveTable
}

var _ relExpr = (*recursiveTable)(nil)
var _ sourceRel = (*recursiveTable)(nil)

func (r *recursiveTable) String() string {
	return formatExpr(r)
}

func (r *recursiveTable) name() string {
	return strings.ToLower(r.table.Name())
}

func (r *recursiveTable) tableId() TableId {
	return tableIdForSource(r.g.id)
}

func (r *recursiveTable) outputCols() sql.Schema {
	return r.table.Schema()
}

func (r *recursiveTable) children() []*exprGroup {
	return nil
}

type recursiveCte struct {
	*relBase
	table *plan.RecursiveCte
}

var _ relExpr = (*recursiveCte)(nil)
var _ sourceRel = (*recursiveCte)(nil)

func (r *recursiveCte) String() string {
	return formatExpr(r)
}

func (r *recursiveCte) name() string {
	return strings.ToLower(r.table.Name())
}

func (r *recursiveCte) tableId() TableId {
	return tableIdForSource(r.g.id)
}

func (r *recursiveCte) outputCols() sql.Schema {
	return r.table.Schema()
}

func (r *recursiveCte) children() []*exprGroup {
	return nil
}

type subqueryAlias struct {
	*relBase
	table *plan.SubqueryAlias
}

var _ relExpr = (*subqueryAlias)(nil)
var _ sourceRel = (*subqueryAlias)(nil)

func (r *subqueryAlias) String() string {
	return formatExpr(r)
}

func (r *subqueryAlias) name() string {
	return strings.ToLower(r.table.Name())
}

func (r *subqueryAlias) tableId() TableId {
	return tableIdForSource(r.g.id)
}

func (r *subqueryAlias) outputCols() sql.Schema {
	return r.table.Schema()
}

func (r *subqueryAlias) children() []*exprGroup {
	return nil
}

type max1Row struct {
	*relBase
	table sql.NameableNode
}

var _ relExpr = (*max1Row)(nil)
var _ sourceRel = (*max1Row)(nil)

func (r *max1Row) String() string {
	return formatExpr(r)
}

func (r *max1Row) name() string {
	return strings.ToLower(r.table.Name())
}

func (r *max1Row) tableId() TableId {
	return tableIdForSource(r.g.id)
}

func (r *max1Row) outputCols() sql.Schema {
	return r.table.Schema()
}

func (r *max1Row) children() []*exprGroup {
	return nil
}

type tableFunc struct {
	*relBase
	table sql.TableFunction
}

var _ relExpr = (*tableFunc)(nil)
var _ sourceRel = (*tableFunc)(nil)

func (r *tableFunc) String() string {
	return formatExpr(r)
}

func (r *tableFunc) name() string {
	return strings.ToLower(r.table.Name())
}

func (r *tableFunc) tableId() TableId {
	return tableIdForSource(r.g.id)
}

func (r *tableFunc) outputCols() sql.Schema {
	return r.table.Schema()
}

func (r *tableFunc) children() []*exprGroup {
	return nil
}

type emptyTable struct {
	*relBase
	table *plan.EmptyTable
}

var _ relExpr = (*emptyTable)(nil)
var _ sourceRel = (*emptyTable)(nil)

func (r *emptyTable) String() string {
	return formatExpr(r)
}

func (r *emptyTable) name() string {
	return strings.ToLower(r.table.Name())
}

func (r *emptyTable) tableId() TableId {
	return tableIdForSource(r.g.id)
}

func (r *emptyTable) outputCols() sql.Schema {
	return r.table.Schema()
}

func (r *emptyTable) children() []*exprGroup {
	return nil
}

type project struct {
	*relBase
	child       *exprGroup
	projections []*exprGroup
}

var _ relExpr = (*project)(nil)

func (r *project) String() string {
	return formatExpr(r)
}

func (r *project) children() []*exprGroup {
	return []*exprGroup{r.child}
}

func (r *project) outputCols() sql.Schema {
	var s = make(sql.Schema, len(r.projections))
	for i, e := range r.projections {
		ref := e.scalar.(*colRef)
		s[i] = &sql.Column{
			Name:     ref.gf.Name(),
			Source:   ref.gf.String(),
			Type:     ref.gf.Type(),
			Nullable: ref.gf.IsNullable(),
		}
	}
	return s
}

type distinct struct {
	*relBase
	child *exprGroup
}

var _ relExpr = (*distinct)(nil)

func (r *distinct) String() string {
	return formatExpr(r)
}

func (r *distinct) children() []*exprGroup {
	return []*exprGroup{r.child}
}

func (r *distinct) outputCols() sql.Schema {
	return r.child.relProps.OutputCols()
}

type filter struct {
	*relBase
	child   *exprGroup
	filters []*exprGroup
}

var _ relExpr = (*filter)(nil)

func (r *filter) String() string {
	return formatExpr(r)
}

func (r *filter) children() []*exprGroup {
	return []*exprGroup{r.child}
}

func (r *filter) outputCols() sql.Schema {
	return r.child.relProps.OutputCols()
}

type equal struct {
	*scalarBase
	left  *exprGroup
	right *exprGroup
}

var _ scalarExpr = (*equal)(nil)

func (r *equal) exprId() scalarExprId {
	return equalExpr
}

func (r *equal) String() string {
	return formatExpr(r)
}

func (r *equal) children() []*exprGroup {
	return []*exprGroup{r.left, r.right}
}

type literal struct {
	*scalarBase
	val interface{}
	typ sql.Type
}

var _ scalarExpr = (*literal)(nil)

func (r *literal) exprId() scalarExprId {
	return literalExpr
}

func (r *literal) String() string {
	return formatExpr(r)
}

func (r *literal) children() []*exprGroup {
	return nil
}

type colRef struct {
	*scalarBase
	col   sql.ColumnId
	table GroupId
	gf    *expression.GetField
}

var _ scalarExpr = (*colRef)(nil)

func (r *colRef) exprId() scalarExprId {
	return colRefExpr
}

func (r *colRef) String() string {
	return formatExpr(r)
}

func (r *colRef) children() []*exprGroup {
	return nil
}

type not struct {
	*relBase
	child *exprGroup
}

var _ scalarExpr = (*not)(nil)

func (r *not) exprId() scalarExprId {
	return notExpr
}

func (r *not) String() string {
	return formatExpr(r)
}

func (r *not) children() []*exprGroup {
	return []*exprGroup{r.child}
}

func (r *not) outputCols() sql.Schema {
	return r.child.relProps.OutputCols()
}

type or struct {
	*scalarBase
	left  *exprGroup
	right *exprGroup
}

var _ scalarExpr = (*or)(nil)

func (r *or) exprId() scalarExprId {
	return orExpr
}

func (r *or) String() string {
	return formatExpr(r)
}

func (r *or) children() []*exprGroup {
	return []*exprGroup{r.left, r.right}
}

type and struct {
	*scalarBase
	left  *exprGroup
	right *exprGroup
}

var _ scalarExpr = (*and)(nil)

func (r *and) exprId() scalarExprId {
	return andExpr
}

func (r *and) String() string {
	return formatExpr(r)
}

func (r *and) children() []*exprGroup {
	return []*exprGroup{r.left, r.right}
}

type inTuple struct {
	*scalarBase
	left  *exprGroup
	right *exprGroup
}

var _ scalarExpr = (*inTuple)(nil)

func (r *inTuple) exprId() scalarExprId {
	return inTupleExpr
}

func (r *inTuple) String() string {
	return formatExpr(r)
}

func (r *inTuple) children() []*exprGroup {
	return []*exprGroup{r.left, r.right}
}

type lt struct {
	*scalarBase
	left  *exprGroup
	right *exprGroup
}

var _ scalarExpr = (*lt)(nil)

func (r *lt) exprId() scalarExprId {
	return ltExpr
}

func (r *lt) String() string {
	return formatExpr(r)
}

func (r *lt) children() []*exprGroup {
	return []*exprGroup{r.left, r.right}
}

type leq struct {
	*scalarBase
	left  *exprGroup
	right *exprGroup
}

var _ scalarExpr = (*leq)(nil)

func (r *leq) exprId() scalarExprId {
	return leqExpr
}

func (r *leq) String() string {
	return formatExpr(r)
}

func (r *leq) children() []*exprGroup {
	return []*exprGroup{r.left, r.right}
}

type gt struct {
	*scalarBase
	left  *exprGroup
	right *exprGroup
}

var _ scalarExpr = (*gt)(nil)

func (r *gt) exprId() scalarExprId {
	return gtExpr
}

func (r *gt) String() string {
	return formatExpr(r)
}

func (r *gt) children() []*exprGroup {
	return []*exprGroup{r.left, r.right}
}

type geq struct {
	*scalarBase
	left  *exprGroup
	right *exprGroup
}

var _ scalarExpr = (*geq)(nil)

func (r *geq) exprId() scalarExprId {
	return geqExpr
}

func (r *geq) String() string {
	return formatExpr(r)
}

func (r *geq) children() []*exprGroup {
	return []*exprGroup{r.left, r.right}
}

type nullSafeEq struct {
	*scalarBase
	left  *exprGroup
	right *exprGroup
}

var _ scalarExpr = (*nullSafeEq)(nil)

func (r *nullSafeEq) exprId() scalarExprId {
	return nullSafeEqExpr
}

func (r *nullSafeEq) String() string {
	return formatExpr(r)
}

func (r *nullSafeEq) children() []*exprGroup {
	return []*exprGroup{r.left, r.right}
}

type regexp struct {
	*scalarBase
	left  *exprGroup
	right *exprGroup
}

var _ scalarExpr = (*regexp)(nil)

func (r *regexp) exprId() scalarExprId {
	return regexpExpr
}

func (r *regexp) String() string {
	return formatExpr(r)
}

func (r *regexp) children() []*exprGroup {
	return []*exprGroup{r.left, r.right}
}

func formatExpr(r exprType) string {
	switch r := r.(type) {
	case *crossJoin:
		return fmt.Sprintf("crossJoin %d %d", r.left.id, r.right.id)
	case *innerJoin:
		return fmt.Sprintf("innerJoin %d %d", r.left.id, r.right.id)
	case *leftJoin:
		return fmt.Sprintf("leftJoin %d %d", r.left.id, r.right.id)
	case *semiJoin:
		return fmt.Sprintf("semiJoin %d %d", r.left.id, r.right.id)
	case *antiJoin:
		return fmt.Sprintf("antiJoin %d %d", r.left.id, r.right.id)
	case *lookupJoin:
		return fmt.Sprintf("lookupJoin %d %d", r.left.id, r.right.id)
	case *concatJoin:
		return fmt.Sprintf("concatJoin %d %d", r.left.id, r.right.id)
	case *hashJoin:
		return fmt.Sprintf("hashJoin %d %d", r.left.id, r.right.id)
	case *mergeJoin:
		return fmt.Sprintf("mergeJoin %d %d", r.left.id, r.right.id)
	case *fullOuterJoin:
		return fmt.Sprintf("fullOuterJoin %d %d", r.left.id, r.right.id)
	case *tableScan:
		return fmt.Sprintf("tableScan: %s", r.name())
	case *values:
		return fmt.Sprintf("values: %s", r.name())
	case *tableAlias:
		return fmt.Sprintf("tableAlias: %s", r.name())
	case *recursiveTable:
		return fmt.Sprintf("recursiveTable: %s", r.name())
	case *recursiveCte:
		return fmt.Sprintf("recursiveCte: %s", r.name())
	case *subqueryAlias:
		return fmt.Sprintf("subqueryAlias: %s", r.name())
	case *max1Row:
		return fmt.Sprintf("max1Row: %s", r.name())
	case *tableFunc:
		return fmt.Sprintf("tableFunc: %s", r.name())
	case *emptyTable:
		return fmt.Sprintf("emptyTable: %s", r.name())
	case *project:
		return fmt.Sprintf("project: %d", r.child.id)
	case *distinct:
		return fmt.Sprintf("distinct: %d", r.child.id)
	case *filter:
		return fmt.Sprintf("filter: %d", r.child.id)
	case *equal:
		return fmt.Sprintf("equal %d %d", r.left.id, r.right.id)
	case *literal:
		return fmt.Sprintf("literal")
	case *colRef:
		return fmt.Sprintf("colRef")
	case *not:
		return fmt.Sprintf("not: %d", r.child.id)
	case *or:
		return fmt.Sprintf("or %d %d", r.left.id, r.right.id)
	case *and:
		return fmt.Sprintf("and %d %d", r.left.id, r.right.id)
	case *inTuple:
		return fmt.Sprintf("inTuple %d %d", r.left.id, r.right.id)
	case *lt:
		return fmt.Sprintf("lt %d %d", r.left.id, r.right.id)
	case *leq:
		return fmt.Sprintf("leq %d %d", r.left.id, r.right.id)
	case *gt:
		return fmt.Sprintf("gt %d %d", r.left.id, r.right.id)
	case *geq:
		return fmt.Sprintf("geq %d %d", r.left.id, r.right.id)
	case *nullSafeEq:
		return fmt.Sprintf("nullSafeEq %d %d", r.left.id, r.right.id)
	case *regexp:
		return fmt.Sprintf("regexp %d %d", r.left.id, r.right.id)
	default:
		panic(fmt.Sprintf("unknown relExpr type: %T", r))
	}
}

func buildRelExpr(b *ExecBuilder, r relExpr, input sql.Schema, children ...sql.Node) (sql.Node, error) {
	var result sql.Node
	var err error

	switch r := r.(type) {
	case *crossJoin:
		result, err = b.buildCrossJoin(r, input, children...)
	case *innerJoin:
		result, err = b.buildInnerJoin(r, input, children...)
	case *leftJoin:
		result, err = b.buildLeftJoin(r, input, children...)
	case *semiJoin:
		result, err = b.buildSemiJoin(r, input, children...)
	case *antiJoin:
		result, err = b.buildAntiJoin(r, input, children...)
	case *lookupJoin:
		result, err = b.buildLookupJoin(r, input, children...)
	case *concatJoin:
		result, err = b.buildConcatJoin(r, input, children...)
	case *hashJoin:
		result, err = b.buildHashJoin(r, input, children...)
	case *mergeJoin:
		result, err = b.buildMergeJoin(r, input, children...)
	case *fullOuterJoin:
		result, err = b.buildFullOuterJoin(r, input, children...)
	case *tableScan:
		result, err = b.buildTableScan(r, input, children...)
	case *values:
		result, err = b.buildValues(r, input, children...)
	case *tableAlias:
		result, err = b.buildTableAlias(r, input, children...)
	case *recursiveTable:
		result, err = b.buildRecursiveTable(r, input, children...)
	case *recursiveCte:
		result, err = b.buildRecursiveCte(r, input, children...)
	case *subqueryAlias:
		result, err = b.buildSubqueryAlias(r, input, children...)
	case *max1Row:
		result, err = b.buildMax1Row(r, input, children...)
	case *tableFunc:
		result, err = b.buildTableFunc(r, input, children...)
	case *emptyTable:
		result, err = b.buildEmptyTable(r, input, children...)
	case *project:
		result, err = b.buildProject(r, input, children...)
	case *filter:
		result, err = b.buildFilter(r, input, children...)
	default:
		panic(fmt.Sprintf("unknown relExpr type: %T", r))
	}

	if err != nil {
		return nil, err
	}

	result, err = r.group().finalize(result, input)
	if err != nil {
		return nil, err
	}
	return result, nil
}

func buildScalarExpr(b *ExecBuilder, r scalarExpr, sch sql.Schema) (sql.Expression, error) {
	switch r := r.(type) {
	case *equal:
		return b.buildEqual(r, sch)
	case *literal:
		return b.buildLiteral(r, sch)
	case *colRef:
		return b.buildColRef(r, sch)
	case *not:
		return b.buildNot(r, sch)
	case *or:
		return b.buildOr(r, sch)
	case *and:
		return b.buildAnd(r, sch)
	case *inTuple:
		return b.buildInTuple(r, sch)
	case *lt:
		return b.buildLt(r, sch)
	case *leq:
		return b.buildLeq(r, sch)
	case *gt:
		return b.buildGt(r, sch)
	case *geq:
		return b.buildGeq(r, sch)
	case *nullSafeEq:
		return b.buildNullSafeEq(r, sch)
	case *regexp:
		return b.buildRegexp(r, sch)
	default:
		panic(fmt.Sprintf("unknown scalarExpr type: %T", r))
	}
}
